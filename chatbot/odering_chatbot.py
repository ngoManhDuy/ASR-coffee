import os
import time
import re
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
from openai import OpenAI
from dotenv import load_dotenv
from chatbot.vector_store_manager import VectorStoreManager

# Load environment variables
load_dotenv()
client = OpenAI()

@dataclass
class OrderItem:
    name: str
    size: str
    price: int
    quantity: int = 1

@dataclass
class ConversationContext:
    current_intent: Optional[str] = None
    pending_item: Optional[str] = None
    pending_size: Optional[str] = None
    last_user_message: str = ""
    conversation_history: List[Dict] = None
    
    def __post_init__(self):
        if self.conversation_history is None:
            self.conversation_history = []

class ImprovedHighlandBot:
    def __init__(self):
        self.vector_manager = VectorStoreManager()
        self.vector_store_id = self.vector_manager.get_vector_store_id()
        self.context = ConversationContext()
        self.current_order: List[OrderItem] = []
        
        print(f"ü§ñ Bot initialized with vector store: {self.vector_store_id}")
    
    def search_menu_simple(self, query: str) -> str:
        """Simple direct search without Assistant API - faster and cleaner."""
        try:
            # Get relevant documents from vector store
            # Using a simple completion with system context instead of assistants
            response = client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {
                        "role": "system",
                        "content": """B·∫°n l√† nh√¢n vi√™n b√°n h√†ng t·∫°i Highland Coffee. 
                        Tr·∫£ l·ªùi ng·∫Øn g·ªçn, th√¢n thi·ªán b·∫±ng ti·∫øng Vi·ªát v√† ti·∫øng anh.
                        D·ª±a v√†o th√¥ng tin menu ƒë·ªÉ t∆∞ v·∫•n ch√≠nh x√°c v·ªÅ ƒë·ªì u·ªëng, gi√° c·∫£, k√≠ch c·ª°.
                        KH√îNG hi·ªÉn th·ªã ngu·ªìn tr√≠ch d·∫´n hay s·ªë th·ª© t·ª± t√†i li·ªáu.
                        ƒê√¥i l√∫c kh√°ch h√†ng s·∫Ω ƒë∆∞a ra m·ªôt s·ªë th√¥ng tin h∆°i kh√≥ hi·ªÉu, kh√¥ng n·∫±m trong menu. Trong tr∆∞·ªùng h·ª£p n√†y,
                        b·∫°n h√£y l·ªãch s·ª±, h·ªèi v√† l√†m r√µ y√™u c·∫ßu c·ªßa kh√°ch h√†ng nh√©!
                        L∆∞u √Ω l√† h√£y CH·ªà ƒë∆∞a ra th√¥ng tin h·ªØu √≠ch v√† ng·∫Øn g·ªçn nh√©. H√£y h·∫°n ch·∫ø s·ª≠ d·ª•ng c√°c k√Ω hi·ªáu, h√£y ch·ªâ vi·∫øt l·ªùi cho t√¥i"""
                    },
                    {
                        "role": "user", 
                        "content": f"Menu Highland Coffee: {self.get_menu_context()}\n\nKh√°ch h·ªèi: {query}"
                    }
                ],
                max_tokens=1000,
                temperature=0.2
            )
            
            # Clean response - remove citations
            response_text = response.choices[0].message.content.strip()
            return self.clean_response(response_text)
            
        except Exception as e:
            print(f"Error in search: {e}")
            return "Xin l·ªói, t√¥i kh√¥ng th·ªÉ t√¨m th√¥ng tin n√†y l√∫c n√†y. B·∫°n c√≥ th·ªÉ h·ªèi v·ªÅ m√≥n kh√°c kh√¥ng?"
    
    def get_menu_context(self) -> str:
        """Get basic menu context - you can expand this with cached menu data."""
        return """Highland Coffee Menu:
        
        C√† Ph√™ Pha Phin: Phin ƒêen, Phin S·ªØa, B·∫°c X√≠u - Size S,M,L (29k-39k)
        C√† Ph√™ Espresso: Americano, Latte, Cappuccino, Mocha - Size M,L,XL (35k-69k) 
        ƒê·ªì U·ªëng ƒê√° Xay: Freeze S√¥-c√¥-la, Cookies & Cream - Size S,M,L (49k-65k)
        Tr√†: Tr√† Sen V√†ng, Tr√† Th·∫°ch ƒê√†o - Size S,M,L (39k-49k)
        Kh√°c: Chanh ƒê√° Xay, S√¥-c√¥-la ƒê√° (39k-54k)"""
    
    def clean_response(self, text: str) -> str:
        """Remove citations and unnecessary formatting."""
        # Remove citation patterns like „Äê4:0‚Ä†source„Äë
        text = re.sub(r'„Äê[^„Äë]*„Äë', '', text)
        # Remove source references
        text = re.sub(r'\[source[^\]]*\]', '', text)
        text = re.sub(r'\(\d+:\d+‚Ä†[^)]*\)', '', text)
        # Clean up extra whitespace
        text = re.sub(r'\s+', ' ', text).strip()
        return text
    
    def detect_intent(self, user_input: str) -> str:
        """Detect user intent based on input and context."""
        user_input_lower = user_input.lower()
        
        # Order management
        if any(word in user_input_lower for word in ["ƒë∆°n h√†ng", "order"]):
            return "show_order"
        elif any(word in user_input_lower for word in ["x√≥a ƒë∆°n", "clear", "h·ªßy"]):
            return "clear_order"
        
        # Size selection context
        if self.context.pending_item and any(word in user_input_lower for word in ["c·ª°", "size", "nh·ªè", "v·ª´a", "l·ªõn", "s", "m", "l"]):
            return "selecting_size"
        
        # Ordering intent
        if any(word in user_input_lower for word in ["mu·ªën", "cho t√¥i", "ƒë·∫∑t", "g·ªçi", "order"]):
            return "ordering"
        
        # Information seeking
        if any(word in user_input_lower for word in ["gi√°", "price", "ti·ªÅn", "bao nhi√™u"]):
            return "asking_price"
        elif any(word in user_input_lower for word in ["g·ª£i √Ω", "recommend", "t∆∞ v·∫•n"]):
            return "asking_recommendation"
        
        return "general_inquiry"
    
    def extract_item_and_size(self, text: str) -> tuple:
        """Extract item name and size from user input."""
        text_lower = text.lower()
        
        # Common items
        items = {
            "freeze s√¥ c√¥ la": "Freeze S√¥-c√¥-la",
            "freeze socola": "Freeze S√¥-c√¥-la", 
            "phin s·ªØa": "Phin S·ªØa",
            "phin ƒëen": "Phin ƒêen",
            "latte": "Latte",
            "cappuccino": "Cappuccino",
            "americano": "Americano"
        }
        
        # Size mappings
        sizes = {
            "nh·ªè": "S", "s": "S", "small": "S",
            "v·ª´a": "M", "m": "M", "medium": "M", 
            "l·ªõn": "L", "l": "L", "large": "L"
        }
        
        found_item = None
        found_size = None
        
        for key, item in items.items():
            if key in text_lower:
                found_item = item
                break
        
        for key, size in sizes.items():
            if key in text_lower:
                found_size = size
                break
                
        return found_item, found_size
    
    def add_to_order(self, item: str, size: str, price: int):
        """Add item to order."""
        order_item = OrderItem(name=item, size=size, price=price)
        self.current_order.append(order_item)
        return f"‚úÖ ƒê√£ th√™m {item} c·ª° {size} ({price:,}ƒë) v√†o ƒë∆°n h√†ng!"
    
    def show_order(self) -> str:
        """Show current order."""
        if not self.current_order:
            return "üõí ƒê∆°n h√†ng c·ªßa b·∫°n ƒëang tr·ªëng."
        
        order_text = "üõí **ƒê∆†N H√ÄNG HI·ªÜN T·∫†I:**\n"
        order_text += "=" * 30 + "\n"
        
        total = 0
        for i, item in enumerate(self.current_order, 1):
            price = item.price * item.quantity
            total += price
            order_text += f"{i}. {item.name} ({item.size}) x{item.quantity} - {price:,}ƒë\n"
        
        order_text += "=" * 30 + "\n"
        order_text += f"üí∞ **T·ªîNG C·ªòNG: {total:,}ƒë**"
        
        return order_text
    
    def clear_order(self) -> str:
        """Clear current order."""
        self.current_order = []
        self.context = ConversationContext()
        return "‚úÖ ƒê√£ x√≥a ƒë∆°n h√†ng!"
    
    def process_user_input(self, user_input: str) -> str:
        """Main processing function with conversation memory."""
        self.context.last_user_message = user_input
        intent = self.detect_intent(user_input)
        
        # Add to conversation history
        self.context.conversation_history.append({
            "role": "user",
            "content": user_input,
            "intent": intent,
            "timestamp": time.time()
        })
        
        # Process based on intent
        if intent == "show_order":
            response = self.show_order()
            
        elif intent == "clear_order":
            response = self.clear_order()
            
        elif intent == "selecting_size":
            response = self.handle_size_selection(user_input)
            
        elif intent == "ordering":
            response = self.handle_ordering(user_input)
            
        else:
            # General inquiry - search menu
            response = self.search_menu_simple(user_input)
            
            # Check if this creates a new ordering context
            item, _ = self.extract_item_and_size(user_input)
            if item and "mu·ªën" in user_input.lower():
                self.context.current_intent = "ordering"
                self.context.pending_item = item
        
        # Add response to history
        self.context.conversation_history.append({
            "role": "assistant", 
            "content": response,
            "timestamp": time.time()
        })
        
        return response
    
    def handle_size_selection(self, user_input: str) -> str:
        """Handle size selection when user specifies size."""
        if not self.context.pending_item:
            return "B·∫°n mu·ªën ch·ªçn k√≠ch c·ª° cho m√≥n g√¨ ·∫°?"
        
        _, size = self.extract_item_and_size(user_input)
        
        if size:
            # Get price for the item and size (simplified)
            price = self.get_price(self.context.pending_item, size)
            
            confirm_msg = f"B·∫°n mu·ªën g·ªçi {self.context.pending_item} c·ª° {size} ({price:,}ƒë) kh√¥ng?"
            self.context.pending_size = size
            
            return confirm_msg
        else:
            return f"B·∫°n mu·ªën {self.context.pending_item} c·ª° n√†o ·∫°? (Nh·ªè/V·ª´a/L·ªõn)"
    
    def handle_ordering(self, user_input: str) -> str:
        """Handle ordering process."""
        item, size = self.extract_item_and_size(user_input)
        
        if item and size:
            price = self.get_price(item, size)
            return self.add_to_order(item, size, price)
        elif item:
            self.context.pending_item = item
            return f"B·∫°n mu·ªën {item} c·ª° n√†o ·∫°? (Nh·ªè: S, V·ª´a: M, L·ªõn: L)"
        else:
            return self.search_menu_simple(user_input)
    
    def get_price(self, item: str, size: str) -> int:
        """Get price for item and size - simplified pricing."""
        # Simplified pricing logic
        base_prices = {
            "Freeze S√¥-c√¥-la": {"S": 49000, "M": 59000, "L": 65000},
            "Phin S·ªØa": {"S": 29000, "M": 35000, "L": 39000},
            "Latte": {"M": 55000, "L": 65000, "XL": 69000},
            "Cappuccino": {"M": 55000, "L": 65000, "XL": 69000}
        }
        
        if item in base_prices and size in base_prices[item]:
            return base_prices[item][size]
        
        # Default fallback
        return {"S": 39000, "M": 49000, "L": 59000}.get(size, 49000)

def print_welcome():
    """Print welcome message."""
    print("\n" + "="*60)
    print("üåü CH√ÄO M·ª™NG ƒê·∫æN V·ªöI HIGHLAND COFFEE! üåü")
    print("="*60)
    print("T√¥i l√† tr·ª£ l√Ω AI v·ªõi tr√≠ nh·ªõ, s·∫µn s√†ng gi√∫p b·∫°n ƒë·∫∑t m√≥n!")
    print("\nüìã H∆Ø·ªöNG D·∫™N:")
    print("‚Ä¢ H·ªèi menu: 'C√≥ nh·ªØng ƒë·ªì u·ªëng g√¨?'")
    print("‚Ä¢ ƒê·∫∑t m√≥n: 'T√¥i mu·ªën freeze s√¥ c√¥ la c·ª° nh·ªè'") 
    print("‚Ä¢ Xem ƒë∆°n: 'ƒë∆°n h√†ng'")
    print("‚Ä¢ X√≥a ƒë∆°n: 'x√≥a ƒë∆°n'")
    print("‚Ä¢ Tho√°t: 'quit'")
    print("="*60)

def main():
    # Initialize bot
    bot = ImprovedHighlandBot()
    
    print_welcome()
    print("üí¨ B·∫°n c√≥ th·ªÉ b·∫Øt ƒë·∫ßu h·ªèi ngay!\n")
    
    while True:
        try:
            user_input = input("üë§ B·∫°n: ").strip()
            
            if user_input.lower() in ['quit', 'exit', 'tho√°t', 'bye']:
                print("\nüôè C·∫£m ∆°n b·∫°n ƒë√£ s·ª≠ d·ª•ng Highland Coffee!")
                print("H·∫πn g·∫∑p l·∫°i! ‚òïÔ∏è\n")
                break
            
            if not user_input:
                continue
            
            # Process with improved bot
            response = bot.process_user_input(user_input)
            
            print("ü§ñ Highland Bot:")
            print("-" * 40)
            print(response)
            print("-" * 40)
            print()
            
        except KeyboardInterrupt:
            print("\n\nüôè C·∫£m ∆°n b·∫°n! H·∫πn g·∫∑p l·∫°i! ‚òïÔ∏è\n")
            break
        except Exception as e:
            print(f"\n‚ùå L·ªói: {e}")
            print("Vui l√≤ng th·ª≠ l·∫°i!\n")

if __name__ == "__main__":
    main() 