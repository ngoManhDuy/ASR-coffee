import os
import time
import re
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
from openai import OpenAI
from dotenv import load_dotenv
from vector_store_manager import VectorStoreManager

# Load environment variables
load_dotenv()
client = OpenAI()

@dataclass
class OrderItem:
    name: str
    size: str
    price: int
    quantity: int = 1

@dataclass
class ConversationContext:
    current_intent: Optional[str] = None
    pending_item: Optional[str] = None
    pending_size: Optional[str] = None
    last_user_message: str = ""
    conversation_history: List[Dict] = None
    preferred_language: str = "auto"  # "auto", "vi", "en"
    
    def __post_init__(self):
        if self.conversation_history is None:
            self.conversation_history = []

class ImprovedHighlandBot:
    def __init__(self):
        self.vector_manager = VectorStoreManager()
        self.vector_store_id = self.vector_manager.get_vector_store_id()
        self.context = ConversationContext()
        self.current_order: List[OrderItem] = []
        
        print(f"ü§ñ Bot initialized with vector store: {self.vector_store_id}")
    
    def search_menu_simple(self, query: str) -> str:
        """Simple direct search without Assistant API - faster and cleaner."""
        try:
            # Get system prompt based on preferred language
            system_prompt = self.get_system_prompt()
            
            # Get relevant documents from vector store
            # Using a simple completion with system context instead of assistants
            response = client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {
                        "role": "system",
                        "content": system_prompt
                    },
                    {
                        "role": "user", 
                        "content": f"Menu Highland Coffee: {self.get_menu_context()}\n\nCustomer asks: {query}"
                    }
                ],
                max_tokens=1000,
                temperature=0.2
            )
            
            # Clean response - remove citations
            response_text = response.choices[0].message.content.strip()
            return self.clean_response(response_text)
            
        except Exception as e:
            print(f"Error in search: {e}")
            if self.context.preferred_language == "en":
                return "Sorry, I cannot find this information right now. Can you ask about something else?"
            else:
                return "Xin l·ªói, t√¥i kh√¥ng th·ªÉ t√¨m th√¥ng tin n√†y l√∫c n√†y. B·∫°n c√≥ th·ªÉ h·ªèi v·ªÅ m√≥n kh√°c kh√¥ng?"
    
    def get_menu_context(self) -> str:
        """Get basic menu context - you can expand this with cached menu data."""
        return """Highland Coffee Menu:
        
        C√† Ph√™ Pha Phin: Phin ƒêen, Phin S·ªØa, B·∫°c X√≠u - Size S,M,L (29k-39k)
        C√† Ph√™ Espresso: Americano, Latte, Cappuccino, Mocha - Size M,L,XL (35k-69k) 
        ƒê·ªì U·ªëng ƒê√° Xay: Freeze S√¥-c√¥-la, Cookies & Cream - Size S,M,L (49k-65k)
        Tr√†: Tr√† Sen V√†ng, Tr√† Th·∫°ch ƒê√†o - Size S,M,L (39k-49k)
        Kh√°c: Chanh ƒê√° Xay, S√¥-c√¥-la ƒê√° (39k-54k)"""
    
    def get_system_prompt(self) -> str:
        """Get system prompt based on user's preferred language."""
        if self.context.preferred_language == "en":
            return """You are a sales staff member at Highland Coffee.
            Respond concisely and friendly in ENGLISH only.
            Based on the menu information, provide accurate advice about drinks, prices, and sizes.
            DO NOT display source citations or document numbers.
            Sometimes customers may provide confusing information not on the menu. In this case,
            please be polite, ask questions and clarify the customer's request!
            Note that you should ONLY provide useful and concise information. Limit the use of symbols, just write words for me."""
        
        elif self.context.preferred_language == "vi":
            return """B·∫°n l√† nh√¢n vi√™n b√°n h√†ng t·∫°i Highland Coffee. 
            Tr·∫£ l·ªùi ng·∫Øn g·ªçn, th√¢n thi·ªán b·∫±ng ti·∫øng Vi·ªát.
            D·ª±a v√†o th√¥ng tin menu ƒë·ªÉ t∆∞ v·∫•n ch√≠nh x√°c v·ªÅ ƒë·ªì u·ªëng, gi√° c·∫£, k√≠ch c·ª°.
            KH√îNG hi·ªÉn th·ªã ngu·ªìn tr√≠ch d·∫´n hay s·ªë th·ª© t·ª± t√†i li·ªáu.
            ƒê√¥i l√∫c kh√°ch h√†ng s·∫Ω ƒë∆∞a ra m·ªôt s·ªë th√¥ng tin h∆°i kh√≥ hi·ªÉu, kh√¥ng n·∫±m trong menu. Trong tr∆∞·ªùng h·ª£p n√†y,
            b·∫°n h√£y l·ªãch s·ª±, h·ªèi v√† l√†m r√µ y√™u c·∫ßu c·ªßa kh√°ch h√†ng nh√©!
            L∆∞u √Ω l√† h√£y CH·ªà ƒë∆∞a ra th√¥ng tin h·ªØu √≠ch v√† ng·∫Øn g·ªçn nh√©. H√£y h·∫°n ch·∫ø s·ª≠ d·ª•ng c√°c k√Ω hi·ªáu, h√£y ch·ªâ vi·∫øt l·ªùi cho t√¥i."""
        
        else:  # auto mode - detect from context
            return """You are a sales staff member at Highland Coffee.
            Respond concisely and friendly. Match the customer's language preference:
            - If they write in English, respond in English
            - If they write in Vietnamese, respond in Vietnamese  
            - If unclear, default to Vietnamese
            Based on the menu information, provide accurate advice about drinks, prices, and sizes.
            DO NOT display source citations or document numbers."""
    
    def clean_response(self, text: str) -> str:
        """Remove citations and unnecessary formatting."""
        # Remove citation patterns like „Äê4:0‚Ä†source„Äë
        text = re.sub(r'„Äê[^„Äë]*„Äë', '', text)
        # Remove source references
        text = re.sub(r'\[source[^\]]*\]', '', text)
        text = re.sub(r'\(\d+:\d+‚Ä†[^)]*\)', '', text)
        # Clean up extra whitespace
        text = re.sub(r'\s+', ' ', text).strip()
        return text
    
    def detect_language(self, user_input: str) -> str:
        """Detect user's preferred language from their input."""
        user_input_lower = user_input.lower()
        
        # Explicit language requests
        if any(phrase in user_input_lower for phrase in [
            "speak english", "use english", "in english", "english please",
            "can you speak english", "switch to english"
        ]):
            return "en"
        
        if any(phrase in user_input_lower for phrase in [
            "n√≥i ti·∫øng vi·ªát", "ti·∫øng vi·ªát", "vietnamese", "vi·ªát nam"
        ]):
            return "vi"
        
        # Language detection based on content
        # Vietnamese indicators
        vietnamese_words = [
            't√¥i', 'b·∫°n', 'l√†', 'v√†', 'c√≥', 'kh√¥ng', 'ƒë∆∞·ª£c', 'n√†y', 'ƒë√≥', 'c·ªßa',
            'cho', 'v·ªõi', 'v·ªÅ', 'm·ªôt', 'nh·ªØng', 't·ª´', '·ªü', 'nh∆∞', 's·∫Ω', 'n√†o',
            'mu·ªën', 'c·∫ßn', 'th√≠ch', 'g√¨', '·∫°', 'em', 'anh', 'ch·ªã', 'xin'
        ]
        
        # English indicators  
        english_words = [
            'i', 'you', 'the', 'a', 'an', 'and', 'or', 'but', 'is', 'are', 
            'was', 'were', 'have', 'has', 'do', 'does', 'will', 'would',
            'can', 'could', 'should', 'want', 'need', 'like', 'what', 'how'
        ]
        
        vietnamese_count = sum(1 for word in vietnamese_words if word in user_input_lower)
        english_count = sum(1 for word in english_words if word in user_input_lower)
        
        if vietnamese_count > english_count:
            return "vi"
        elif english_count > vietnamese_count:
            return "en"
        
        return "auto"  # Cannot determine
    
    def detect_intent(self, user_input: str) -> str:
        """Detect user intent based on input and context."""
        user_input_lower = user_input.lower()
        
        # Order management
        if any(word in user_input_lower for word in ["ƒë∆°n h√†ng", "order", "my order", "cart"]):
            return "show_order"
        elif any(word in user_input_lower for word in ["x√≥a ƒë∆°n", "clear", "h·ªßy", "cancel", "remove"]):
            return "clear_order"
        
        # Size selection context
        if self.context.pending_item and any(word in user_input_lower for word in [
            "c·ª°", "size", "nh·ªè", "v·ª´a", "l·ªõn", "s", "m", "l",
            "small", "medium", "large"
        ]):
            return "selecting_size"
        
        # Ordering intent
        if any(word in user_input_lower for word in [
            "mu·ªën", "cho t√¥i", "ƒë·∫∑t", "g·ªçi", "order", "want", "get", "have",
            "i want", "i would like", "can i get", "can i have", "give me"
        ]):
            return "ordering"
        
        # Information seeking
        if any(word in user_input_lower for word in [
            "gi√°", "price", "ti·ªÅn", "bao nhi√™u", "how much", "cost", "pricing"
        ]):
            return "asking_price"
        elif any(word in user_input_lower for word in [
            "g·ª£i √Ω", "recommend", "t∆∞ v·∫•n", "suggestion", "what do you recommend",
            "what's good", "what should i"
        ]):
            return "asking_recommendation"
        
        return "general_inquiry"
    
    def extract_item_and_size(self, text: str) -> tuple:
        """Extract item name and size from user input."""
        text_lower = text.lower()
        
        # Common items
        items = {
            "freeze s√¥ c√¥ la": "Freeze S√¥-c√¥-la",
            "freeze socola": "Freeze S√¥-c√¥-la", 
            "phin s·ªØa": "Phin S·ªØa",
            "phin ƒëen": "Phin ƒêen",
            "latte": "Latte",
            "cappuccino": "Cappuccino",
            "americano": "Americano"
        }
        
        # Size mappings
        sizes = {
            "nh·ªè": "S", "s": "S", "small": "S",
            "v·ª´a": "M", "m": "M", "medium": "M", 
            "l·ªõn": "L", "l": "L", "large": "L"
        }
        
        found_item = None
        found_size = None
        
        for key, item in items.items():
            if key in text_lower:
                found_item = item
                break
        
        for key, size in sizes.items():
            if key in text_lower:
                found_size = size
                break
                
        return found_item, found_size
    
    def add_to_order(self, item: str, size: str, price: int):
        """Add item to order."""
        order_item = OrderItem(name=item, size=size, price=price)
        self.current_order.append(order_item)
        
        if self.context.preferred_language == "en":
            return f"‚úÖ Added {item} size {size} ({price:,}ƒë) to your order!"
        else:
            return f"‚úÖ ƒê√£ th√™m {item} c·ª° {size} ({price:,}ƒë) v√†o ƒë∆°n h√†ng!"
    
    def show_order(self) -> str:
        """Show current order."""
        if not self.current_order:
            if self.context.preferred_language == "en":
                return "üõí Your order is empty."
            else:
                return "üõí ƒê∆°n h√†ng c·ªßa b·∫°n ƒëang tr·ªëng."
        
        if self.context.preferred_language == "en":
            order_text = "üõí **CURRENT ORDER:**\n"
            order_text += "=" * 30 + "\n"
            
            total = 0
            for i, item in enumerate(self.current_order, 1):
                price = item.price * item.quantity
                total += price
                order_text += f"{i}. {item.name} ({item.size}) x{item.quantity} - {price:,}ƒë\n"
            
            order_text += "=" * 30 + "\n"
            order_text += f"üí∞ **TOTAL: {total:,}ƒë**"
        else:
            order_text = "üõí **ƒê∆†N H√ÄNG HI·ªÜN T·∫†I:**\n"
            order_text += "=" * 30 + "\n"
            
            total = 0
            for i, item in enumerate(self.current_order, 1):
                price = item.price * item.quantity
                total += price
                order_text += f"{i}. {item.name} ({item.size}) x{item.quantity} - {price:,}ƒë\n"
            
            order_text += "=" * 30 + "\n"
            order_text += f"üí∞ **T·ªîNG C·ªòNG: {total:,}ƒë**"
        
        return order_text
    
    def clear_order(self) -> str:
        """Clear current order."""
        self.current_order = []
        self.context = ConversationContext()
        
        if self.context.preferred_language == "en":
            return "‚úÖ Order cleared!"
        else:
            return "‚úÖ ƒê√£ x√≥a ƒë∆°n h√†ng!"
    
    def process_user_input(self, user_input: str) -> str:
        """Main processing function with conversation memory."""
        self.context.last_user_message = user_input
        
        # Detect and update language preference
        detected_language = self.detect_language(user_input)
        if detected_language != "auto":
            self.context.preferred_language = detected_language
        
        intent = self.detect_intent(user_input)
        
        # Add to conversation history
        self.context.conversation_history.append({
            "role": "user",
            "content": user_input,
            "intent": intent,
            "language": detected_language,
            "timestamp": time.time()
        })
        
        # Process based on intent
        if intent == "show_order":
            response = self.show_order()
            
        elif intent == "clear_order":
            response = self.clear_order()
            
        elif intent == "selecting_size":
            response = self.handle_size_selection(user_input)
            
        elif intent == "ordering":
            response = self.handle_ordering(user_input)
            
        else:
            # General inquiry - search menu
            response = self.search_menu_simple(user_input)
            
            # Check if this creates a new ordering context
            item, _ = self.extract_item_and_size(user_input)
            if item and "mu·ªën" in user_input.lower():
                self.context.current_intent = "ordering"
                self.context.pending_item = item
        
        # Add response to history
        self.context.conversation_history.append({
            "role": "assistant", 
            "content": response,
            "timestamp": time.time()
        })
        
        return response
    
    def handle_size_selection(self, user_input: str) -> str:
        """Handle size selection when user specifies size."""
        if not self.context.pending_item:
            if self.context.preferred_language == "en":
                return "What item would you like to choose a size for?"
            else:
                return "B·∫°n mu·ªën ch·ªçn k√≠ch c·ª° cho m√≥n g√¨ ·∫°?"
        
        _, size = self.extract_item_and_size(user_input)
        
        if size:
            # Get price for the item and size (simplified)
            price = self.get_price(self.context.pending_item, size)
            
            if self.context.preferred_language == "en":
                confirm_msg = f"Would you like to order {self.context.pending_item} size {size} ({price:,}ƒë)?"
            else:
                confirm_msg = f"B·∫°n mu·ªën g·ªçi {self.context.pending_item} c·ª° {size} ({price:,}ƒë) kh√¥ng?"
            
            self.context.pending_size = size
            return confirm_msg
        else:
            if self.context.preferred_language == "en":
                return f"What size would you like for {self.context.pending_item}? (Small/Medium/Large)"
            else:
                return f"B·∫°n mu·ªën {self.context.pending_item} c·ª° n√†o ·∫°? (Nh·ªè/V·ª´a/L·ªõn)"
    
    def handle_ordering(self, user_input: str) -> str:
        """Handle ordering process."""
        item, size = self.extract_item_and_size(user_input)
        
        if item and size:
            price = self.get_price(item, size)
            return self.add_to_order(item, size, price)
        elif item:
            self.context.pending_item = item
            if self.context.preferred_language == "en":
                return f"What size would you like for {item}? (Small: S, Medium: M, Large: L)"
            else:
                return f"B·∫°n mu·ªën {item} c·ª° n√†o ·∫°? (Nh·ªè: S, V·ª´a: M, L·ªõn: L)"
        else:
            return self.search_menu_simple(user_input)
    
    def get_price(self, item: str, size: str) -> int:
        """Get price for item and size - simplified pricing."""
        # Simplified pricing logic
        base_prices = {
            "Freeze S√¥-c√¥-la": {"S": 49000, "M": 59000, "L": 65000},
            "Phin S·ªØa": {"S": 29000, "M": 35000, "L": 39000},
            "Latte": {"M": 55000, "L": 65000, "XL": 69000},
            "Cappuccino": {"M": 55000, "L": 65000, "XL": 69000}
        }
        
        if item in base_prices and size in base_prices[item]:
            return base_prices[item][size]
        
        # Default fallback
        return {"S": 39000, "M": 49000, "L": 59000}.get(size, 49000)
    
    def get_welcome_message(self) -> str:
        """Get welcome message in appropriate language."""
        if self.context.preferred_language == "en":
            return "Hello! Welcome to Highland Coffee! How can I help you today? ‚òïÔ∏è"
        else:
            return "Ch√†o b·∫°n! Ch√†o m·ª´ng ƒë·∫øn Highland Coffee! B·∫°n c·∫ßn t∆∞ v·∫•n g√¨ h√¥m nay? ‚òïÔ∏è"

def print_welcome():
    """Print welcome message."""
    print("HIGHLAND COFFEE ORDERING")
    print("="*60)

def main():
    # Initialize bot
    bot = ImprovedHighlandBot()
    
    print_welcome()
    print("üí¨ B·∫°n c√≥ th·ªÉ b·∫Øt ƒë·∫ßu h·ªèi ngay! / You can start asking now!\n")
    
    # Show initial greeting
    initial_greeting = bot.get_welcome_message()
    print("ü§ñ Highland Bot:")
    print("-" * 40)
    print(initial_greeting)
    print("-" * 40)
    print()
    
    while True:
        try:
            user_input = input("üë§ B·∫°n: ").strip()
            
            if user_input.lower() in ['quit', 'exit', 'tho√°t', 'bye']:
                print("H·∫πn g·∫∑p l·∫°i! \n")
                break
            
            if not user_input:
                continue
            
            # Process with improved bot
            response = bot.process_user_input(user_input)
            
            print("ü§ñ Highland Bot:")
            print("-" * 40)
            print(response)
            print("-" * 40)
            print()
            
        except KeyboardInterrupt:
            print("\n\nüôè C·∫£m ∆°n b·∫°n! H·∫πn g·∫∑p l·∫°i! ‚òïÔ∏è\n")
            break
        except Exception as e:
            print(f"\n‚ùå L·ªói: {e}")
            print("Vui l√≤ng th·ª≠ l·∫°i!\n")

if __name__ == "__main__":
    main() 